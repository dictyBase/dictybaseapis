syntax = "proto3";

package dictybase.annotation;
import "google/api/annotations.proto";
import "google/protobuf/timestamp.proto";
import "google/protobuf/empty.proto";
import "github.com/mwitkow/go-proto-validators/validator.proto";


option cc_enable_arenas = true;
option go_package = "github.com/dictyBase/go-genproto/dictybaseapis/annotation;annotation";
option java_multiple_files = true;
option java_outer_classname = "AnnotationProto";
option java_package = "org.dictybase.annotation";
option objc_class_prefix = "DICTYAPI";

// The tagged annotation service specification
service TaggedAnnotationService {
    // Retrieves the specified tagged annotation
    rpc GetAnnotation(AnnotationId) returns (TaggedAnnotation) {}
    // Retrieves a single tagged annotation associated with an entry
    rpc GetEntryAnnotation(EntryAnnotationRequest) returns (TaggedAnnotation) {}
    // Retrieves all tagged annotations
    rpc ListAnnotations(ListParameters) returns (TaggedAnnotationCollection) {}
    // Create a tagged annotation
    rpc CreateAnnotation(NewTaggedAnnotation) returns (TaggedAnnotation) {}
    // Update an existing annotation, in this case a new annotation entry is
    // created with a link to the previous annotation(copy on write).
    rpc UpdateAnnotation(TaggedAnnotationUpdate) returns (TaggedAnnotation) {}
    // Delete an existing annotation
    rpc DeleteAnnotation(AnnotationId) returns (google.protobuf.Empty) {}
}

message AnnotationId {
    // unique identifier for the annotation
    string id = 1 [(validator.field) = {string_not_empty : true}];
}


// Definition for various fields that are needed for fetching annotation for an
// entry. The tag, ontology and entry_id must be provided, version and rank are
// optional and their default values are used.
message EntryAnnotationRequest {
    // An identifiable tagname for the annotation, primarily
    // a structured tag, generally an ontology term.
    string tag = 1 [(validator.field) = {string_not_empty : true}];
    // unique identifier of a biological entity that is being annotated
    string entry_id = 2 [(validator.field) = {string_not_empty : true}];
    // Name of ontology in which the tag name is taken
    string ontology = 3 [(validator.field) = {string_not_empty : true}];
    // Ordering of annotation when an entry has multiple annotations with
    // identical tag from the same ontology. By default, rank 0 is assumed.
    int64 rank = 4;
    // Status for active or retired annotation. Active annotation is chosen by default.
    bool is_obsolete = 5;
}

// List of paginated tagged annotations
message TaggedAnnotationCollection {
    message Data {
        // resource name, by default should be annotation
        string type = 1;
        // unique identifier for the annotation
        string id = 2;
        TaggedAnnotationAttributes attributes = 3;
    }
    repeated Data data = 1 [(validator.field) = {msg_exists : true}];
    Meta meta = 3 [(validator.field) = {msg_exists : true}];
}


// Definition of an tag value based biological annotation where the tag always
// represents a term from ontology.
message TaggedAnnotation {
    message Data {
        // resource name, by default should be annotation
        string type = 1;
        // unique identifier for the annotation
        string id = 2;
        TaggedAnnotationAttributes attributes = 3;
    }
    Data data = 1 [(validator.field) = {msg_exists : true}];
}

// Definition of various tagged annotation attributes
message TaggedAnnotationAttributes {
    // annotation in plain text format
    string value = 1 [(validator.field) = {string_not_empty : true}];
    // serialized text content in a format recognized by frontend rich text
    // editor
    string editable_value = 2 [(validator.field) = {string_not_empty : true}];
    // Unique identifier(generally email) of the user who created the annotation
    string created_by = 3 [(validator.field) = {string_not_empty : true}];
    // Timestamp for creation
    google.protobuf.Timestamp created_at = 4 [(validator.field) = {msg_exists : true}];
    // An identifiable tagname for the annotation, primarily
    // a structured tag, generally an ontology term.
    string tag = 5 [(validator.field) = {string_not_empty : true}];
    // version refers to the current version no
    int64 version = 6 [(validator.field) = {int_gt : 0}];
    // unique identifier of a biological entity that is being annotated
    string entry_id = 7 [(validator.field) = {string_not_empty : true}];
    // Name of ontology in which the tag name is taken
    string ontology = 8 [(validator.field) = {string_not_empty : true}];
    // Ordering of annotation when an entry has multiple annotations with
    // identical tag from the same ontology.
    int64 rank = 9;
    // Status for active or retired annotation
    bool is_obsolete = 10;
}


// Definition for creating a new tagged annotation
message NewTaggedAnnotation {
    message Data {
        // resource name, by default should be annotation
        string type = 1;
        NewTaggedAnnotationAttributes attributes = 2;
    }
    Data data = 1 [(validator.field) = {msg_exists : true}];
}

// NewTaggedAnnotation defines attributes for creating a new annotation
message NewTaggedAnnotationAttributes {
    // annotation in plain text format
    string value = 1 [(validator.field) = {string_not_empty : true}];
    // serialized text content in a format recognized by frontend rich text
    // editor
    string editable_value = 2 [(validator.field) = {string_not_empty : true}];
    // Unique identifier(generally email) of the user who created the annotation
    string created_by = 3 [(validator.field) = {string_not_empty : true}];
    // An identifiable tagname for the annotation, primarily
    // a structured tag, generally an ontology term.
    string tag = 4 [(validator.field) = {string_not_empty : true}];
    // unique identifier of a biological entity that is being annotated
    string entry_id = 5 [(validator.field) = {string_not_empty : true}];
    // Name of ontology from which the tag name is taken
    string ontology = 6 [(validator.field) = {string_not_empty : true}];
    // Ordering of annotation when an entry has multiple annotations with
    // identical tag from the same ontology. By default, rank 0 is used.
    int64 rank = 7;
}


// Definition for updating an existing annotation
message TaggedAnnotationUpdate {
    message Data {
        // resource name, by default should be annotation
        string type = 1;
        // unique identifier for the annotation
        string id = 2 [(validator.field) = {string_not_empty : true}];
        TaggedAnnotationUpdateAttributes attributes = 3;
    }
    Data data = 1 [(validator.field) = {msg_exists : true}];
}


// TaggedUpdateAnnotation defines attributes for updating an existing annotation
message TaggedAnnotationUpdateAttributes {
    // annotation in plain text format
    string value = 1 [(validator.field) = {string_not_empty : true}];
    // serialized text content in a format recognized by frontend rich text
    // editor
    string editable_value = 2 [(validator.field) = {string_not_empty : true}];
    // Unique identifier(generally email) of the user who created the annotation
    string created_by = 3 [(validator.field) = {string_not_empty : true}];
}


// ListParameters defines fields for manipulating output of TaggedAnnotation collection
message ListParameters {
    // A unique pointer to the next set of result in the list
    int64 cursor = 1;
    // Maximum number of records that can be fetch per request
    int64 limit = 2;
    // The `filter` field restricts the data return by the collection. To use
    // it, supply one or multiple allowed fields to filter followed
    // by a filter expression. It uses the following syntax...
    //        field_name operator expression
    //
    // The following fields of `AnnotationAttributes` definition are allowed to
    // be used for filtering
    //   * entry_id    - The entry that is being annotated (string)
    //   * value       - The annotation in plain text format (string) 
    //   * created_by  - Email id of the user (string)
    //   * tag         - Tag name, a term from an ontology (string).
    //   * ontology    - Ontology that provides the tag names (string).
    //   * version     - Version no (number).
    //
    // field_name - Any one of the allowed field_name of the `AnnotationAttributes` definition.
    // operator - Defines the type of filter match to use. It could be any of
    // the following four and all of them should be URL-encoded for http request.
    //
    //        Operators for strings
    //              =~    Contains substring
    //              !~   Not contains substring
    //              ===  Equals
    //              !==  Not equals
    //
    //        Operators for numbers
    //              ==  Equals
    //              !=  Not equals
    //              >   Greater than
    //              <   Less than
    //              =<  Less than equal to
    //              >=  Greater than equal to
    //
    // expression - The value that will be included or excluded from the
    // result. URL-reserved characters must be URL-encoded for http request.
    //
    //           filter: "created_by==caboose@abc.com"
    //           filter: "entry_id==DDB_G4839483"
    //           filter: "value~actin"
    //
    // Filter can be combined using OR or AND boolean logic.
    //   * The OR is represented using a comma(,).
    //   * The AND is represented using a semi-colon(;).
    //   * AND and OR operators can be combined and AND takes precedence over OR.
    //
    //           filter: "value~cytoskeletion;tag==cell membrane;ontology==cellular"
    //
    string filter = 3;
    // The sort field allow to sort the data return by the collection based on
    // fields of `AnnotationAttributes. To use it, supply a comma separated one
    // or more allowed field from the definition of `AnnotationAttributes`.
}

// Metadata definition for traversing the collection
message Meta {
    // A unique pointer to the next set of result in the collection. Set the
    // cursor value parameter to the value of next_cursor to retrieve the next
    // set of collection using the same method
    int64 next_cursor = 1;
    // Maximum number of records that can be fetch per request
    int64 limit = 2;
    // Total number of records in the collection.
    int64 total = 3;
}
